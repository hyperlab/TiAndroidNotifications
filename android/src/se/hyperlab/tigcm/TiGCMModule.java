/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package se.hyperlab.tigcm;

import java.util.HashMap;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.titanium.util.TiConvert;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.support.v4.content.LocalBroadcastManager;

import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.GooglePlayServicesUtil;

import org.json.JSONObject;
import org.json.JSONException;


@Kroll.module(name="TiGCM", id="se.hyperlab.tigcm")
public class TiGCMModule extends KrollModule
{
  private static final String TAG = "TiGCMModule";

  public static final String PROPERTY_DEVICE_TOKEN = "deviceToken";
  public static final String INTENT_FILTER_REGISTRATION_COMPLETE = "registrationComplete";
  public static final String PROPERTY_MESSAGE = "message";
  public static final String PROPERTY_REGISTER = "register";
  public static final String PROPERTY_SENDER_ID = "GCM_sender_id";
  public static final String PROPERTY_INTENT_EXTRA_KEY = "notification";
  public static final String PROPERTY_NOTIFICATION_TITLE = "title";
  public static final String PROPERTY_NOTIFICATION_CONTENT = "message";
  public static final String PROPERTY_NOTIFICATION_DATA = "data";
  public static final String PROPERTY_NOTIFICATION_COUNTER = "ntf_counter";
  public static final String PROPERTY_PENDING_DATA = "pending_data";

  private static final int PLAY_SERVICES_RESOLUTION_REQUEST = 9000;

  private BroadcastReceiver registrationBroadcastReceiver;

  private static KrollFunction messageCallback;
  private static KrollFunction registerCallback;

  private static JSONObject launchData = null;

  private static TiGCMModule instance = null;

  public static TiGCMModule getInstance() {
    return instance;
  }

  public TiGCMModule()
  {
    super();

    messageCallback = null;
    registerCallback = null;

    instance = this;
  }

  @Kroll.onAppCreate
  public static void onAppCreate(TiApplication app)
  {
    Log.d(TAG, "inside onAppCreate");

    if(!app.getAppProperties().hasProperty(PROPERTY_NOTIFICATION_COUNTER)) {
      app.getAppProperties().setInt(PROPERTY_NOTIFICATION_COUNTER, 0);
    }
  }

  @Kroll.method
  public void registerForPushNotifications(Object arg) {
    if(TiApplication.getInstance().getAppProperties().hasProperty(PROPERTY_PENDING_DATA)) {
      try {
        launchData = new JSONObject(TiApplication.getInstance().getAppProperties().getString(PROPERTY_PENDING_DATA, ""));
      } catch (JSONException e) {
        Log.d(TAG, "Failed to populate launchData.");
      }
      Log.d(TAG, "Get data from props: " + launchData);
      TiApplication.getInstance().getAppProperties().removeProperty(PROPERTY_PENDING_DATA);
    }

    HashMap<String, Object> options = (HashMap<String, Object>) arg;
    Object message = options.get(PROPERTY_MESSAGE);
    Object register = options.get(PROPERTY_REGISTER);

    if(message instanceof KrollFunction) {
      Log.d(TAG, "Setting message callback");
      messageCallback = (KrollFunction) message;
    }
    if(register instanceof KrollFunction) {
      Log.d(TAG, "Setting register callback");
      registerCallback = (KrollFunction) register;
    }

    registrationBroadcastReceiver = new BroadcastReceiver() {
      @Override
      public void onReceive(Context context, Intent intent) {
        Log.i(TAG, "Registration complete");
      }
    };
    
    if (checkPlayServices(TiApplication.getAppCurrentActivity())) {
      Intent intent = new Intent(TiApplication.getInstance().getApplicationContext(), TiGCMRegistrationIntentService.class);
      TiApplication.getInstance().startService(intent);
    }
  }

  @Override
  public void onResume(Activity activity) {
      super.onResume(activity);
      LocalBroadcastManager.getInstance(TiApplication.getInstance().getApplicationContext()).registerReceiver(registrationBroadcastReceiver, new IntentFilter(INTENT_FILTER_REGISTRATION_COMPLETE));
  }

  @Override
  public void onPause(Activity activity) {
      LocalBroadcastManager.getInstance(TiApplication.getInstance().getApplicationContext()).unregisterReceiver(registrationBroadcastReceiver);
      super.onPause(activity);
  }

  private boolean checkPlayServices(Activity activity) {
    int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(TiApplication.getInstance().getApplicationContext());
    if (resultCode != ConnectionResult.SUCCESS) {
        if (GooglePlayServicesUtil.isUserRecoverableError(resultCode)) {
            GooglePlayServicesUtil.getErrorDialog(resultCode, activity, PLAY_SERVICES_RESOLUTION_REQUEST).show();
        } else {
            Log.i(TAG, "This device is not supported.");
            TiApplication.getAppCurrentActivity().finish();
        }
        return false;
    }
    return true;
  }

  public void onRegister(String token) {
    Log.d(TAG, "Fire register callback");
    if(registerCallback != null) {
      HashMap data = new HashMap();
      data.put(PROPERTY_DEVICE_TOKEN, token);
      registerCallback.call(getKrollObject(), data);
    }
  }

  public static JSONObject bundleToJSON(Bundle source) {
    JSONObject output = new JSONObject();
    if(source != null) {
      for(String key : source.keySet()) {
        try {
          output.put(key, source.get(key));
        } catch(JSONException e) {
          Log.d(TAG, "Failed to set " + key + " in bundleToJSON.");
        }
      }
    }

    return output;
  }

  public void onMessage(Bundle data) {
    Log.d(TAG, "Fire message callback");
    if(messageCallback != null) {
      messageCallback.call(getKrollObject(), (HashMap)KrollDict.fromJSON(bundleToJSON(data)));
      Log.d(TAG, "MessageCallback was called");
    }
  }

  public void setData(JSONObject data) {
    Log.d(TAG, "Set data");
    launchData = data;
  }

  @Kroll.method
  public HashMap getAndClearData() {
    if(launchData != null) {
      JSONObject data = launchData;
      launchData = null;
      return (HashMap)KrollDict.fromJSON(data);
    } else {
      return null;
    }
  }

  @Kroll.method
  public void clearNotifications() {
    TiApplication app = TiApplication.getInstance();

    int ntfCount = app.getAppProperties().getInt(PROPERTY_NOTIFICATION_COUNTER, 0);

    Log.d(TAG, "Clearing " + ntfCount + " notifications");

    if(ntfCount > 0) {
      Intent intent = new Intent(app.getApplicationContext(), TiGCMNotificationPublisher.class);
      for(int i = 0; i < ntfCount; i++) {
        PendingIntent pendingIntent = PendingIntent.getBroadcast(app.getApplicationContext(), i, intent, PendingIntent.FLAG_ONE_SHOT);
        AlarmManager alarmManager = (AlarmManager)app.getApplicationContext().getSystemService(Context.ALARM_SERVICE);
        alarmManager.cancel(pendingIntent);
        pendingIntent.cancel();
      }

      app.getAppProperties().setInt(PROPERTY_NOTIFICATION_COUNTER, 0);
    }
  }

  @Kroll.method
  public void scheduleNotification(HashMap data) {
    TiApplication app = TiApplication.getInstance();

    long time = (long)TiConvert.toDouble(data.get("time"));
    int ntfId = app.getAppProperties().getInt(PROPERTY_NOTIFICATION_COUNTER, 0);

    Log.d(TAG, "Scheduling notification " + ntfId + " at " + time);
    
    Intent intent = new Intent(app.getApplicationContext(), TiGCMNotificationPublisher.class);
    intent.putExtra(PROPERTY_NOTIFICATION_DATA, data);
    PendingIntent pendingIntent = PendingIntent.getBroadcast(app.getApplicationContext(), ntfId, intent, PendingIntent.FLAG_ONE_SHOT);

    AlarmManager alarmManager = (AlarmManager)app.getApplicationContext().getSystemService(Context.ALARM_SERVICE);
    alarmManager.set(AlarmManager.RTC_WAKEUP, time, pendingIntent);

    app.getAppProperties().setInt(PROPERTY_NOTIFICATION_COUNTER, ntfId+1);
  }

}
